{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user within the Inventory Ace application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "firstName": {
          "type": "string",
          "description": "The first name of the user."
        },
        "lastName": {
          "type": "string",
          "description": "The last name of the user."
        },
        "email": {
          "type": "string",
          "description": "The email address of the user.",
          "format": "email"
        },
        "roleId": {
          "type": "string",
          "description": "Reference to the Role entity. (Relationship: Role 1:N User)"
        },
        "createdAt": {
          "type": "string",
          "description": "The date and time when the user account was created.",
          "format": "date-time"
        },
        "lastLogin": {
          "type": "string",
          "description": "The date and time of the user's last login.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "firstName",
        "lastName",
        "email",
        "roleId",
        "createdAt"
      ]
    },
    "Role": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Role",
      "type": "object",
      "description": "Represents a role within the application, such as Admin, Manager, or Staff.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Role entity."
        },
        "name": {
          "type": "string",
          "description": "The name of the role (e.g., Admin, Manager, Staff)."
        },
        "permissions": {
          "type": "array",
          "description": "A list of permissions associated with this role.",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "name"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user data. Path-based ownership: only the user (or an admin) can access their own document.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "/roles/{roleId}",
        "definition": {
          "entityName": "Role",
          "schema": {
            "$ref": "#/backend/entities/Role"
          },
          "description": "Stores role definitions. Admin access required to manage roles.",
          "params": [
            {
              "name": "roleId",
              "description": "The unique identifier of the role."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to provide a secure, scalable, and easily debuggable system for Inventory Ace, adhering to the principles of Authorization Independence, Clarity of Intent, DBAC (Database-Based Access Control), and QAPs (Rules are not Filters). This is achieved through denormalization, structural segregation, and consistent access modeling.\n\n1.  **Authorization Independence (CRITICAL):** The design avoids hierarchical authorization dependencies (`get()`). User roles are managed through a dedicated `/roles/{roleId}` collection and roles are associated to the users through the `roleId` field in the `/users/{userId}`. This eliminates the need for security rules to perform `get()` operations on parent documents, which would break atomic operations (transactions/batches) and make debugging more difficult. This approach relies on DBAC, where roles are stored in the database and authorization relies solely on `request.auth.uid`.\n\n2.  **Structural Segregation (Homogeneous Security Posture):** The `/users/{userId}` collection stores user-specific data, while the `/roles/{roleId}` collection stores role definitions. This segregation ensures that each collection has a homogeneous security posture, simplifying security rules and making them easier to understand and maintain. The security rules for `/users/{userId}` can focus on ownership (`request.auth.uid == userId`), while the security rules for `/roles/{roleId}` can focus on administrative access.\n\n3.  **Access Modeling (Standardization and Consistency):**\n    *   **Private Data:** User data is stored under `/users/{userId}`, adhering to the Path-Based ownership model. This ensures that only the authenticated user can access their own data.\n    *   **Global Roles (DBAC):** Roles are managed in the `/roles/{roleId}` collection. The use of dedicated collections like `/roles` is preferred over custom claims to ensure simple and debuggable security rules.\n\n4.  **QAPs (Rules are not Filters):** The data structure supports secure `list` operations. Rules do not filter, instead the data is structured so that list operations will only return the data that the user is authorized to see. For example, listing users is an admin level permission so only an admin would have access to list the users. The structure must enable secure `list` operations.\n\n5.  **Invariants:** The structure supports the integrity of ownership through path-based ownership for user data. Timestamps, such as `createdAt` and `lastLogin` are stored directly in the user document to maintain data integrity.\n"
  }
}